
\documentclass[a4paper]{report}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}

\title{Segundo Trabalho prático da disciplina de \\  Algoritmos e estruturas de dados II}

\author{Ricardo Coelho Ferreira \\ Cintia Franciele \\ Dayane Apaline}

\date{\today}

\begin{document}
\maketitle

\begin{abstract}

Este Trabalho refere-se a implementação de técnicas de hashing  estudadas na discipina CEA030 ao longo do segundo período de 2014. Além das técnicas de manipulação de funções hash, também foram implementadas formas de  tratamento de colisões, que eventualmente possam ocorrer, na criação da tabela hash. Parte do desenvolvimento é relativo a criação de uma forma de hash não clássica, mas criada pelos autores do trabalho. 

\end{abstract}

\section{Estrutura geral  do  trabalho}

Foi utilizada a liguagem c++ para realizar o hashing, criar e inserir nas tabelas e realizar comunicação com o usuário do programa.

Este relatório foi organizado de forma a compreender uma revisão teórica básica e prover algum entendimento sobre como foram  implementados os métodos, não constituindo portanto, nem uma documentação  do programa, nem um profundo estudo teórico sobre a área.

\section{Hashing}
Tabelas hash são utilizadas em ciência da computação, para dispersar inteiros positivos em uma tabela, através de uma função de correspondência direta, entre elemento(número a ser inserido) e ínidice de sua posição na tabela, essa função é chamada de função de hash, o processo de utiliza-lá para fazer tal mapeamento de hashing.

A escolha da função de hash é feita de forma que o mapeamento inverso da função seja impossível, ou seja, de forma que não seja possível, dado um índice, descobrir qual elemento deve ocupar essa posição.

A grande vantagem do uso de tabelas hash está no fato de que, desprezando os casos de colisão, a busca possui complexidade \large$O(1)$.\normalsize


\section{Métodos Clássicos}

Alguns tipos particulares de função Hash merecem ser ressaltados, dentre eles:

\subsection{Método da divisão}

Neste caso, toma-se o resto da divisão da chave pelo  tamanho da tabela como função de hash.

seja $chave$ o elemento a ser inserido e $tam$ o tamanho da tabela

$$H(chave)=chave\ mod\ tam$$

Código em Cpp:

\begin{verbatim}
int hashingFunc1(int chave, int tam){//tam  é  o tamanho da tabela
    return chave % tam;
}


\end{verbatim}
\subsection{Método da multiplicação}

Neste caso, toma-se o produto do tamanho da tabela pela parte fracionária do produto entre a chave e uma constante característica do método, como função de hash.

seja $chave$ o elemento a ser inserido, $tam$ o tamanho da tabela e $cons$ a constante do método,

$$H(chave)=tam*(cons*chave\ mod \ 1)$$

Código em Cpp:

\begin{verbatim}
int hashingFunc2(int chave, int tam, float cons){
    return (int)(tam*(cons*chave-(int)(cons*chave)));
}

\end{verbatim}

\section{Nova função hash criada}

Nosso objetivo foi criar uma função que pudesse promover um bom espalhamento dos números pela tabela, verificamos que para algumas instâncias aleatórias ela teve performance melhor que os dois métodos anteriores, no entanto isso não pode ser verificado novamente, pois as instâncias foram "aleatórias"(máquinas não podem realmente gerar sequências aleatórias, amenos que peguem dados sobre observação de fenômenos naturais em algum banco de dados que muda em tempo real).

É perceptível, que dada a função de hash, sua complexidade é tão grande que dificilmente ela iria coincidir duas chaves em um mesmo índice, são chances remotas, que no entanto ocorreram algumas vezes, para uma quantidade de chaves bem grande, em um um intervalo pequeno.


Código em Cpp:
\begin{verbatim}

int nossoHash(int chave, int tam){
    return ((int)(pow(((int)(pow(chave*1.6180339887,2)))%tam,2)
    *1.6180339887))%tam;
}

\end{verbatim}

\section{Tratamento de Colisões}

Muitas das funções de hash analisadas, acabam por gerar saídas iguais, para um certo grupo de entradas, mesmo que diferentes, neste caso, dizemos que houve colisão. Tal evento deve ser tratado de acordo com os objetivos de criação da tabela, pois afinal talvez não seja importante que todos os elementos sejam inseridos, assim em caso de colisão bastaria eliminar o elemento, porém isso nem sempre ocorre, por isso existem formas mais elegantes de lidar com as colisões, que geram como efeito colateral, um aumento imprevisível na função de complexidade da busca.

Os métodos mais comuns de tratamento de colisão são:

\subsection{Primeira posição vazia}
Como o prórpio nome diz, busca a primeira posição vazia após o índice retornado pela função de hash.

\subsection{Re-Hash}
Aplica-se outra função de hash a chave, pois será menos provável que a chave receba o mesmo índice atribuido pela função de hash anterior.

\subsection{Lista de lista}

Caso uma linha da tabela esteja ocupado com um elemento, utiliza-se de uma lista de lista, para que mais de um elemento possa ser colocado sob o mesmo índice, sendo o índice das sublistas determinado unicamente pela ordem de inserção.  É óbvio que o  problema desta abordagem é  o aumento da complexidade de pior caso, que passa a ser \large$O(n)$.\normalsize

\section{Conclusões}

Realizamos alguns testes, variando intervalos e quantidade de números gerados, a título de curiosidade e podemos garantir que a instância proposta(50 números entre 0-100, com tabela de tamanho 30) é calculada sem problema algum.

\section{Referências}

\begin{itemize}

\item \begin{verbatim}http://www.tutorialspoint.com/dbms/dbms_hashing.htm\end{verbatim}

\item \begin{verbatim}http://www.inf.ufsc.br/~ine5384-hp/Hashing/\end{verbatim}

\end{itemize}















\end{document}